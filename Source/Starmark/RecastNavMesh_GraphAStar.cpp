#include "RecastNavMesh_GraphAStar.h"


#include "Actor_WorldGrid.h"


// FGridPathFilter Functions
// In these functions, we always assume the WorldGrid is valid
// IF the WorldGrid isn't valid, we default to the RecastNavMesh implementation so
// these functions don't get used
// --------------------------------------------------

float FGridPathFilter::GetHeuristicScale() const
{
	return 1.f;
}

float FGridPathFilter::GetHeuristicCost(const int32 StartNodeReference, const int32 EndNodeReference) const
{
	return GetTraversalCost(StartNodeReference, EndNodeReference);
}

float FGridPathFilter::GetTraversalCost(const int32 StartNodeReference, const int32 EndNodeReference) const
{
	// If EndNodeReference is a valid index of the GridTiles array, return the tile cost
	// If not, return 1 because FGraphAStar needs the traversal cost to be greater than 0
	if (NavMeshReference.WorldGrid->GridTiles.IsValidIndex(EndNodeReference)) {
		return NavMeshReference.WorldGrid->GridTiles[EndNodeReference].Cost;
	}
	else {
		return 1.f;
	}
}

bool FGridPathFilter::IsTraversalAllowed(const int32 NodeA, const int32 NodeB) const
{
	// If NodeB is a valid index of the GridTiles array, return bIsBlocking
	// If not, assume we can traverse, so return true
	if (NavMeshReference.WorldGrid->GridTiles[NodeB].bIsBlocking) {
		return !NavMeshReference.WorldGrid->GridTiles[NodeB].bIsBlocking;
	}
	else {
		return true;
	}
}

bool FGridPathFilter::WantsPartialSolution() const 
{
	return true;
}


FPathFindingResult ARecastNavMesh_GraphAStar::FindPath(const FNavAgentProperties &AgentProperties, const FPathFindingQuery &Query)
{
	// Since this function is static, we can't access class member variables (like WorldGrid) and 'this'
	// FPathFindingQuery contains a pointer to the ANavigationData object
	const ANavigationData *Self = Query.NavData.Get();
	check(Cast<const ARecastNavMesh_GraphAStar>(Self));

	// This function allows us to acces member variables and functions
	const ARecastNavMesh_GraphAStar *GraphAStarNavMesh 
	{
		Cast<const ARecastNavMesh_GraphAStar>(Self)
	};

	if (Self == NULL) {
		return ENavigationQueryResult::Error;
	}

	// This struct contains the result of our search and the path that the AI will follow
	FPathFindingResult Result(ENavigationQueryResult::Error);
		
	FNavigationPath *NavPath = Query.PathInstanceToFill.Get();
	FGridNavMeshPath *NavMeshPath = NavPath ? NavPath->CastPath<FGridNavMeshPath>() : nullptr;

	if (NavMeshPath) {
		Result.Path = Query.PathInstanceToFill;
		NavMeshPath->ResetForRepath();
	}
	else {
		Result.Path = Self->CreatePathInstance<FGridNavMeshPath>(Query);
		NavPath = Result.Path.Get();
		NavMeshPath = NavPath ? NavPath->CastPath<FGridNavMeshPath>() : nullptr;
	}

	const FNavigationQueryFilter *NavFilter = Query.QueryFilter.Get();

	if (NavMeshPath && NavFilter) {
		NavMeshPath->ApplyFlags(Query.NavDataFlags);

		const FVector AdjustedEndLocation = NavFilter->GetAdjustedEndLocation(Query.EndLocation);
		if ((Query.StartLocation - AdjustedEndLocation).IsNearlyZero() == true) {
			Result.Path->GetPathPoints().Reset();
			Result.Path->GetPathPoints().Add(FNavPathPoint(AdjustedEndLocation));
			Result.Result = ENavigationQueryResult::Success;
		}
		// End of RecastNavMesh code
		// Start of our code
		else {
			// Reset the PathPoints array
			Result.Path->GetPathPoints().Reset();

			// The Pathfinder needs start and end points, so we create two temporary sets of coordinates
			FHCubeCoord StartCoord
			{
				GraphAStarNavMesh->WorldGrid->WorldToTile(Query.StartLocation)
			};
			FHCubeCoord EndCoord
			{
				GraphAStarNavMesh->WorldGrid->WorldToTile(Query.EndLocation)
			};

			// Then, we search in the WorldGrid CubeCoordinates array for the indices of the items that equal our temporary coordinates
			const int32 StartIndex
			{
				GraphAStarNavMesh->WorldGrid->GridCoordinates.IndexOfByKey(StartCoord)
			};
			const int32 EndIndex
			{
				GraphAStarNavMesh->WorldGrid->GridCoordinates.IndexOfByKey(EndCoord)
			};

			// We need the indices because FGraphAStar requires indices
			// Here we save the path generated by the Pathfinder
			TArray<int32> PathIndices;

			//Internalize the pathfinder. Pass our RecastNavMesh_GraphAStar as a parameter so it can use the functions we implemented
			FGraphAStar<ARecastNavMesh_GraphAStar> Pathfinder(*GraphAStarNavMesh);

			// Run the A* algorithm. The FGraphAStar::FindPath function requires a 'start index', an 'end index', a FGridPathFilter which requires our GraphAStarNavMesh,
			// and a reference to the array we store our path indices are stored
			EGraphAStarResult AStarResult
			{ 
				Pathfinder.FindPath(StartIndex, EndIndex, FGridPathFilter(*GraphAStarNavMesh), PathIndices) 
			};

			switch (AStarResult)
			{
				case GoalUnreachable:
					Result.Result = ENavigationQueryResult::Invalid;
					break;
				case InfiniteLoop:
					Result.Result = ENavigationQueryResult::Error;
					break;
				case SearchFail:
					Result.Result = ENavigationQueryResult::Fail;
					break;
				// If the search is successfull, process the computed path
				// This involves taking the array of indices and figuring out the path locations from those,
				// then passing them to the PathPoints array
				case SearchSuccess:
					Result.Result = ENavigationQueryResult::Success;

					// The PathIndices array doesn't contain the starting point, so we add it manually
					Result.Path->GetPathPoints().Add(FNavPathPoint(Query.StartLocation));

					// Traverse the PathIndices array and build the FNavPathPoints
					for (const int32 &PathIndex : PathIndices) {
						// Get a temporary CubeCoordinate from our WorldGrid
						FHCubeCoord GridCoord
						{
							GraphAStarNavMesh->WorldGrid->GridCoordinates[PathIndex]
						};

						// Temporary FNavPathPoint
						FNavPathPoint PathPoint{};

						// Since we can only create a WorldGrid with Cube Coordinates, we must check if the current index is a valid index for the GridTiles array
						if (GraphAStarNavMesh->WorldGrid->GridTiles.IsValidIndex(PathIndex)) {
							// If the Index is valid, we can calculate the location of the PathPoint, using the world space coordinates of the current Cube Coordinate
							// as a base and offset the Z coordinate.
							PathPoint.Location = GraphAStarNavMesh->WorldGrid->TileToWorld(GridCoord) +
								FVector(0.f, 0.f, GraphAStarNavMesh->WorldGrid->GridTiles[PathIndex].Cost + GraphAStarNavMesh->PathPointZOffset);
						}
						else {
							// If the Index isn't valid, transform the coordinates from Cube space to world space and pass it to the PathPoint
							PathPoint.Location = GraphAStarNavMesh->WorldGrid->TileToWorld(GridCoord);
						}

						// Add the computed PathPoint to the PathPoints array
						PathPoint.Location = GraphAStarNavMesh->WorldGrid->TileToWorld(GridCoord);
					}

					// When finished, mark the park as Ready
					Result.Path->MarkReady();
					break;
			}
			// End of our code
		}
	}

	return Result;
}


void ARecastNavMesh_GraphAStar::SetWorldGrid(AActor_WorldGrid* NewWorldGrid)
{
	if (NewWorldGrid) {
		// If we have a valid pointer, we use our implementation of the FindPath function
		WorldGrid = NewWorldGrid;
		FindPathImplementation = FindPath;
	}
	else {
		// If we don't have a valid pointer, we use the default RecastNavMesh implenentation of the FindPath function
		WorldGrid = nullptr;
		FindPathImplementation = Super::FindPath;
	}
}


// FGraphAStar Functions
// --------------------------------------------------
int32 ARecastNavMesh_GraphAStar::GetNeighbourCount(FNodeRef NodeReference) const
{
	return 8;
}

bool ARecastNavMesh_GraphAStar::IsValidRef(FNodeRef NodeReference) const
{
	return WorldGrid->GridCoordinates.IsValidIndex(NodeReference);
}

ARecastNavMesh_GraphAStar::FNodeRef
ARecastNavMesh_GraphAStar::GetNeighbour(const FNodeRef NodeReference, const int32 NeighbourIndex) const
{
	FHCubeCoord Neighbour
	{
		WorldGrid->GetNeighbour(WorldGrid->GridCoordinates[NodeReference], WorldGrid->GetDirection(NeighbourIndex))
	};

	return WorldGrid->GridCoordinates.IndexOfByKey(Neighbour);
}